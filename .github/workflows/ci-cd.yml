name: Java CI/CD

on:
  push:
    branches:
      - develop
  pull_request:
    branches:
      - develop

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        java-version: [17, 21]

    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ matrix.java-version }}
          distribution: 'temurin'
      - name: Set profile
        run: echo "SPRING_PROFILES_ACTIVE=test" >> $GITHUB_ENV
      - name: Clean build
        run: ./gradlew clean
      - name: Create test secret file
        run: |
          set +x
          mkdir -p src/test/resources
          echo "${{ secrets.TEST_SECRET_YML }}" > src/test/resources/application-test-secret.yml
      - name: Run tests
        run: ./gradlew test

  build-and-push-image:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'

    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
      - name: Build JAR
        run: ./gradlew bootJar
      - name: Prepare Docker build context
        run: |
          mkdir -p docker-build
          cp build/libs/*.jar docker-build/app.jar
          cp Dockerfile docker-build/
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Create ECR Repository if not exists
        run: |
          set +x
          echo "::add-mask::${{ secrets.AWS_REGION }}"
          aws ecr describe-repositories --repository-names community-backend --region ${{ secrets.AWS_REGION }} 2>/dev/null || \
          aws ecr create-repository \
            --repository-name community-backend \
            --image-scanning-configuration scanOnPush=true \
            --encryption-configuration encryptionType=AES256 \
            --region ${{ secrets.AWS_REGION }}

      - name: Update Parameter Store with ECR Image URI
        run: |
          set +x
          echo "::add-mask::${{ secrets.AWS_REGION }}"
          ECR_URI=$(aws ecr describe-repositories --repository-names community-backend --query 'repositories[0].repositoryUri' --output text --region ${{ secrets.AWS_REGION }})
          echo "::add-mask::$ECR_URI"
          ECR_BACKEND_IMAGE="${ECR_URI}:latest"
          echo "::add-mask::$ECR_BACKEND_IMAGE"
          aws ssm put-parameter \
            --name "/community/ecr_backend_image" \
            --value "$ECR_BACKEND_IMAGE" \
            --type "String" \
            --overwrite \
            --region ${{ secrets.AWS_REGION }} || echo "Parameter Store update failed, but continuing..."

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Docker Image to ECR
        uses: docker/build-push-action@v5
        with:
          context: ./docker-build
          file: ./docker-build/Dockerfile
          push: true
          tags: ${{ steps.login-ecr.outputs.registry }}/community-backend:latest
          platforms: linux/arm64

  deploy:
    needs: build-and-push-image
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy to ASG
        run: |
          set -e
          set +x
          REGION="${{ secrets.AWS_REGION }}"
          ASG_NAME="community-backend-asg"
          TARGET_GROUP_NAME="community-backend-tg"
          LAUNCH_TEMPLATE_NAME="community-backend-lt"
          ECR_REPO="community-backend"
          
          cleanup_on_error() {
            if [ -n "$NEW_INSTANCE_ID" ] && [ "$NEW_INSTANCE_ID" != "" ]; then
              aws autoscaling terminate-instance-in-auto-scaling-group \
                --instance-id $NEW_INSTANCE_ID \
                --should-decrement-desired-capacity \
                --region $REGION 2>/dev/null || true
            fi
            if [ -n "$MAX_SIZE_INCREASED" ] && [ "$MAX_SIZE_INCREASED" = "true" ]; then
              aws autoscaling update-auto-scaling-group \
                --auto-scaling-group-name $ASG_NAME \
                --max-size $ORIGINAL_MAX_SIZE \
                --region $REGION 2>/dev/null || true
            fi
            if [ -n "$DESIRED_INCREASED" ] && [ "$DESIRED_INCREASED" = "true" ]; then
              aws autoscaling update-auto-scaling-group \
                --auto-scaling-group-name $ASG_NAME \
                --desired-capacity $ORIGINAL_DESIRED \
                --region $REGION 2>/dev/null || true
            fi
          }
          trap cleanup_on_error ERR EXIT
          
          if ! aws ecr describe-repositories --repository-names $ECR_REPO --region $REGION >/dev/null 2>&1; then
            echo "Error: ECR repository $ECR_REPO not found"
            exit 1
          fi
          
          ECR_URI=$(aws ecr describe-repositories --repository-names $ECR_REPO --query 'repositories[0].repositoryUri' --output text --region $REGION)
          if [ -z "$ECR_URI" ] || [ "$ECR_URI" = "None" ]; then
            echo "Error: Failed to get ECR repository URI"
            exit 1
          fi
          
          IMAGE_EXISTS=$(aws ecr describe-images --repository-name $ECR_REPO --image-ids imageTag=latest --query 'imageDetails[0].imageTags[0]' --output text --region $REGION 2>/dev/null || echo "None")
          if [ "$IMAGE_EXISTS" = "None" ]; then
            LATEST_DIGEST=$(aws ecr describe-images --repository-name $ECR_REPO --query 'sort_by(imageDetails, &imagePushedAt)[-1].imageDigest' --output text --region $REGION 2>/dev/null || echo "")
            if [ -z "$LATEST_DIGEST" ]; then
              echo "Error: No images found in ECR repository"
              exit 1
            fi
            LATEST_IMAGE="${ECR_URI}@${LATEST_DIGEST}"
          else
            LATEST_IMAGE="${ECR_URI}:latest"
          fi
          
          if ! aws ssm put-parameter --name "/community/ecr_backend_image" --value "$LATEST_IMAGE" --type "String" --overwrite --region $REGION >/dev/null 2>&1; then
            echo "Error: Failed to update Parameter Store"
            exit 1
          fi
          
          if ! aws ec2 describe-launch-templates --launch-template-names $LAUNCH_TEMPLATE_NAME --region $REGION >/dev/null 2>&1; then
            echo "Error: Launch template $LAUNCH_TEMPLATE_NAME not found"
            exit 1
          fi
          
          LATEST_VERSION=$(aws ec2 describe-launch-template-versions --launch-template-name $LAUNCH_TEMPLATE_NAME --versions '$Latest' --query 'LaunchTemplateVersions[0].VersionNumber' --output text --region $REGION 2>/dev/null || echo "")
          if [ -z "$LATEST_VERSION" ] || [ "$LATEST_VERSION" = "None" ]; then
            echo "Error: Failed to get latest launch template version"
            exit 1
          fi
          if ! aws ec2 create-launch-template-version --launch-template-name $LAUNCH_TEMPLATE_NAME --source-version $LATEST_VERSION --region $REGION >/dev/null 2>&1; then
            echo "Warning: Failed to create new launch template version"
          fi
          
          if ! aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names $ASG_NAME --region $REGION >/dev/null 2>&1; then
            echo "Error: Auto Scaling Group $ASG_NAME not found"
            exit 1
          fi
          
          CURRENT_DESIRED=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names $ASG_NAME \
            --query 'AutoScalingGroups[0].DesiredCapacity' \
            --output text \
            --region $REGION)
          
          if [ "$CURRENT_DESIRED" = "None" ] || [ -z "$CURRENT_DESIRED" ]; then
            echo "Error: Failed to get current desired capacity"
            exit 1
          fi
          
          if [ "$CURRENT_DESIRED" = "0" ]; then
            if ! aws autoscaling update-auto-scaling-group --auto-scaling-group-name $ASG_NAME --desired-capacity 1 --region $REGION >/dev/null 2>&1; then
              echo "Error: Failed to start ASG instance"
              exit 1
            fi
            exit 0
          fi
          
          CURRENT_INSTANCES=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names $ASG_NAME \
            --query 'AutoScalingGroups[0].Instances[*].InstanceId' \
            --output text \
            --region $REGION)
          
          CURRENT_MAX=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names $ASG_NAME \
            --query 'AutoScalingGroups[0].MaxSize' \
            --output text \
            --region $REGION)
          
          if [ "$CURRENT_MAX" = "None" ] || [ -z "$CURRENT_MAX" ]; then
            echo "Error: Failed to get current max size"
            exit 1
          fi
          
          ORIGINAL_DESIRED=$CURRENT_DESIRED
          ORIGINAL_MAX_SIZE=$CURRENT_MAX
          NEW_DESIRED=$((CURRENT_DESIRED + 1))
          MAX_SIZE_INCREASED="false"
          DESIRED_INCREASED="false"
          
          if [ "$CURRENT_MAX" -lt "$NEW_DESIRED" ]; then
            if ! aws autoscaling update-auto-scaling-group --auto-scaling-group-name $ASG_NAME --max-size $NEW_DESIRED --region $REGION >/dev/null 2>&1; then
              echo "Error: Failed to increase max size"
              exit 1
            fi
            MAX_SIZE_INCREASED="true"
          fi
          
          if ! aws autoscaling update-auto-scaling-group --auto-scaling-group-name $ASG_NAME --desired-capacity $NEW_DESIRED --region $REGION >/dev/null 2>&1; then
            echo "Error: Failed to increase desired capacity"
            exit 1
          fi
          DESIRED_INCREASED="true"
          
          NEW_INSTANCE_ID=""
          for i in {1..30}; do
            sleep 10
            ALL_INSTANCES=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names $ASG_NAME \
              --query 'AutoScalingGroups[0].Instances[*].InstanceId' \
              --output text \
              --region $REGION)
            
            for INSTANCE_ID in $ALL_INSTANCES; do
              if [[ ! " $CURRENT_INSTANCES " =~ " $INSTANCE_ID " ]]; then
                NEW_INSTANCE_ID=$INSTANCE_ID
                break 2
              fi
            done
          done
          
          if [ -z "$NEW_INSTANCE_ID" ]; then
            echo "Error: New instance creation failed or timeout"
            exit 1
          fi
          
          if ! aws elbv2 describe-target-groups --names $TARGET_GROUP_NAME --region $REGION >/dev/null 2>&1; then
            echo "Error: Target group $TARGET_GROUP_NAME not found"
            exit 1
          fi
          
          TARGET_GROUP_ARN=$(aws elbv2 describe-target-groups \
            --names $TARGET_GROUP_NAME \
            --query 'TargetGroups[0].TargetGroupArn' \
            --output text \
            --region $REGION)
          
          if [ -z "$TARGET_GROUP_ARN" ] || [ "$TARGET_GROUP_ARN" = "None" ]; then
            echo "Error: Failed to get target group ARN"
            exit 1
          fi
          
          HEALTH_STATUS=""
          for i in {1..30}; do
            sleep 10
            HEALTH_STATUS=$(aws elbv2 describe-target-health \
              --target-group-arn $TARGET_GROUP_ARN \
              --targets Id=$NEW_INSTANCE_ID \
              --query 'TargetHealthDescriptions[0].TargetHealth.State' \
              --output text \
              --region $REGION 2>/dev/null || echo "initial")
            
            if [ "$HEALTH_STATUS" = "healthy" ]; then
              break
            fi
          done
          
          if [ "$HEALTH_STATUS" != "healthy" ]; then
            echo "Error: Health check failed. Status: $HEALTH_STATUS"
            exit 1
          fi
          
          for OLD_INSTANCE_ID in $CURRENT_INSTANCES; do
            if [ -n "$OLD_INSTANCE_ID" ] && [ "$OLD_INSTANCE_ID" != "None" ]; then
              aws autoscaling terminate-instance-in-auto-scaling-group \
                --instance-id $OLD_INSTANCE_ID \
                --should-decrement-desired-capacity \
                --region $REGION >/dev/null 2>&1 || true
            fi
          done
          
          if ! aws autoscaling update-auto-scaling-group --auto-scaling-group-name $ASG_NAME --desired-capacity $ORIGINAL_DESIRED --region $REGION >/dev/null 2>&1; then
            echo "Error: Failed to restore desired capacity"
            exit 1
          fi
          DESIRED_INCREASED="false"
          
          if [ "$MAX_SIZE_INCREASED" = "true" ]; then
            if ! aws autoscaling update-auto-scaling-group --auto-scaling-group-name $ASG_NAME --max-size $ORIGINAL_MAX_SIZE --region $REGION >/dev/null 2>&1; then
              echo "Error: Failed to restore max size"
              exit 1
            fi
            MAX_SIZE_INCREASED="false"
          fi
          
          trap - ERR EXIT
